# MySQL

## 1.1MySQL逻辑框架

服务器逻辑架构图：

![image-20240221163001637](C:\Users\10309\Desktop\学习\弟哥\网络协议\图片\image-20240221163001637.png)

#### MySQL三层架构：

1. **最上层服务层：** 处理连接、授权认证、安全等通用的网络客户端/服务器工具或服务功能。这一层提供了基础的服务和安全控制
2. **中间层服务层：** MySQL 的核心服务功能大多数集中在这一层。包括查询解析、分析、优化、缓存以及内置函数。此层实现了跨存储引擎的功能，如存储过程、触发器、视图等。这一层的服务提供了数据库的核心功能，处理用户的 SQL 查询请求，并对其进行解析、优化、执行
3. **存储引擎层：** 包含了实际的数据存储和提取。不同的存储引擎负责 MySQL 数据的不同存储和检索方式。每个存储引擎都有自己的优势和劣势，而存储引擎之间的差异对上层的查询过程是**透明的**。存储引擎通过 API 与服务器进行通信，提供了一系列底层函数用于执行基本的数据库操作。虽然存储引擎之间不直接通信，但它们通过存储引擎 API 与中间层服务进行交互，使得在同一个 MySQL 服务器上可以使用不同的存储引擎

### 1.1.1 连接管理与安全性

每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程

当客户端（应用）连接到 MySQL 服务器时，服务器需要对其进行认证。认证基于用户名、原始主机信息和密码。如果使用了安全套接字（SSL）的方式连接，还可以使用 X.509 证书认证。一旦客户端连接成功，服务器会继续验证该客户端是否具有执行某个特定查询的权限，例如是否允许客户端对 "world" 数据库的 "Country" 表执行 SELECT 语句

这种连接管理与安全性的机制确保了在连接建立之后，MySQL 服务器能够进行有效的身份验证和权限控制，从而保障数据的安全性和合法性

### 1.1.2 优化与执行

MySQL 在处理查询时，会经历解析查询、创建内部数据结构（解析树），然后进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。用户可以通过特殊的关键字提示（hint）优化器，影响其决策过程。此外，用户还可以请求优化器解释（explain）优化过程的各个因素，了解服务器如何进行优化决策，并提供一个参考基准，便于用户重构查询、schema 或修改相关配置，以使应用尽可能高效运行

化器并不关心表使用的是什么存储引擎，但存储引擎对于查询的优化是有影响的。优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等

对于 SELECT 语句，在解析查询之前，服务器会先检查查询缓存（Query Cache）。如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集

### 1.2 并发控制

当多个查询需要在同一时刻修改数据时，会出现并发控制问题。在 MySQL 中，这个问题在服务器层和存储引擎层都需要得到处理。

以 Unix 系统的邮箱为例，如果两个进程同时向同一个邮箱投递邮件，可能导致数据破坏。为了防止这种情况，良好设计的系统使用锁来防止并发修改。在数据库系统中，MySQL 通过并发控制机制来确保数据的一致性和完整性

### 1.2.1 读写锁

在处理并发读或写时，采用读写锁系统来解决问题。读锁是共享的，多个客户可以同时读取同一个资源而互不干扰。写锁是排他的，一个写锁会阻塞其他写锁和读锁，以确保在给定时间里只有一个用户能执行写入并防止其他用户读取正在写入的同一资源。

在实际数据库系统中，MySQL通过读写锁管理并发操作。锁的内部管理通常是透明的

### 1.2.2 锁粒度

锁策略决定了锁的开销和数据的安全性之间的平衡。在MySQL中，支持多种锁策略，但其中两种最重要的是表锁和行级锁。

1. **表锁（Table Lock）：**
   - 锁定整张表，是MySQL中最基本的锁策略，开销最小。
   - 对表进行写操作前需要获得写锁，会阻塞其他用户对该表的所有读写操作。
   - 在没有写锁时，其他读取的用户可以获得读锁，读锁之间不相互阻塞。
   - 在特定场景中，表锁可能有较好性能，例如，`READ LOCAL`表锁支持某些类型的并发写操作。
   - 写锁比读锁有更高的优先级，写锁请求可能插入到读锁队列的前面。
2. **行级锁（Row Lock）：**
   - 可以最大程度支持并发处理，但带来了更大的锁开销。
   - InnoDB、XtraDB等存储引擎实现了行级锁。
   - 行级锁只在存储引擎层实现，MySQL服务器层不了解存储引擎中的锁实现。
   - 行级锁只锁定需要修改的数据部分，最大程度减小锁的范围。
   - 存储引擎通过实现行级锁来支持高并发，MySQL服务器层无需关心锁的具体实现。

在不同的应用场景中，选择合适的锁策略是优化性能的关键



### 1.3 事务

事务是数据库中一组原子性的SQL查询或独立的工作单元。一个事务要么全部执行成功，要么全部失败回滚。MySQL支持ACID（原子性、一致性、隔离性、持久性）特性，确保数据库的稳健性。

- **原子性（Atomicity）**：
  - 事务被视为不可分割的最小工作单元。
  - 所有操作要么全部提交成功，要么全部失败回滚。
- **一致性（Consistency）**：
  - 数据库总是从一个一致性状态转换到另一个一致性状态。
  - 事务保证数据库的一致性，即使在执行中途出现故障。
- **隔离性（Isolation）**：
  - 事务的修改在提交前对其他事务不可见。
  - 隔离性保证一个事务的操作不会影响其他事务，并防止并发访问的数据混乱。
- **持久性（Durability）**：
  - 一旦事务提交，其修改永久保存到数据库中。
  - 持久性确保数据在系统崩溃或故障时不会丢失。

ACID特性的实现对于数据库系统是关键的，但也带来了一些性能开销。MySQL的存储引擎架构允许用户根据业务需求选择合适的存储引擎，以平衡性能和ACID特性。即使某个存储引擎不支持事务，用户仍可以通过`LOCK TABLES`语句提供一定程度的保护



### 1.3.1 隔离级别

隔离级别定义了一个事务中的修改在事务内和事务间的可见性，涉及到脏读、不可重复读、和幻读等问题。MySQL支持四种隔离级别：

- **READ UNCOMMITTED（未提交读）**：
  - 允许事务读取其他未提交事务的修改，可能导致脏读（Dirty Read）。
  - 性能相对较好，但缺乏隔离性，很少在实际应用中使用。
- **READ COMMITTED（提交读）**：
  - 事务只能“看见”已经提交的事务所做的修改，解决了脏读问题。
  - 默认隔离级别，适用于大多数应用场景。
- **REPEATABLE READ（可重复读）**：
  - 保证在同一个事务中多次读取同样记录的结果是一致的，解决了脏读和不可重复读问题。
  - 采用锁定读取的方式，可能出现幻读问题。
- **SERIALIZABLE（可串行化）**：
  - 强制事务串行执行，避免了脏读、不可重复读、和幻读的问题。
  - 在读取每一行数据时都会加锁，可能导致性能问题，一般很少使用。

默认情况下，MySQL的可重复读（REPEATABLE READ）是默认的事务隔离级别。根据具体业务需求和性能要求，可以选择适当的隔离级别

![image-20240223152541956](C:\Users\10309\Desktop\学习\弟哥\网络协议\图片\image-20240223152541956.png)

### 1.3.2 死锁

死锁是指两个或多个事务互相占用对方需要的资源，并请求对方释放资源，导致恶性循环的现象。产生死锁的原因通常是事务在不同的顺序锁定资源或者同时锁定相同资源。

举例说明，考虑两个事务同时处理 `StockPrice` 表：

事务1：

```mysql
START TRANSACTION;
UPDATE StockPrice SET close=45.50 WHERE stock_id=4 AND date='2002-05-01';
UPDATE StockPrice SET close=19.80 WHERE stock_id=3 AND date='2002-05-02';
COMMIT;
```

事务2：

```mysql
START TRANSACTION;
UPDATE StockPrice SET high=20.12 WHERE stock_id=3 AND date='2002-05-02';
UPDATE StockPrice SET high=47.20 WHERE stock_id=4 AND date='2002-05-01';
COMMIT;
```

如果两个事务同时执行第一条 `UPDATE` 语句，更新了同一行数据，那么它们会锁定该行数据。接着，每个事务尝试执行第二条 `UPDATE` 语句，却发现该行已被对方锁定，两个事务都等待对方释放锁，形成死锁。

数据库系统实现了死锁检测和死锁超时机制来解决这类问题。复杂的系统，如InnoDB存储引擎，能够检测死锁并立即返回错误。解决死锁问题的方式有多种，包括回滚持有最少行级排他锁的事务，或者在锁等待超时后放弃锁请求。存储引擎的锁行为和顺序会影响死锁的发生，因此应用程序在设计时需要考虑如何处理死锁。通常，重新执行因死锁回滚的事务可以解决死锁问题

### 1.3.3 事务日志

事务日志的使用可以提高事务的效率。存储引擎在修改表的数据时，通过记录修改行为到事务日志，实现只需修改内存拷贝而不必每次都将修改的数据直接持久到磁盘。事务日志采用追加方式记录，使得写入日志的操作是磁盘上一小块区域内的顺序IO，相比随机IO更加高效。因此，事务日志的方式通常更快，能够提升事务处理的效率。

事务日志的写入是持久化的，采用追加式写入。一旦事务日志中记录了修改操作，即使内存中的数据尚未写回磁盘，系统在后台也可以逐步将修改的数据刷回磁盘。这种实现方式被称为预写式日志（Write-Ahead Logging，WAL），修改数据需要写两次磁盘。

当系统崩溃时，如果数据的修改已经记录到了事务日志并持久化，但实际数据本身还没有写回磁盘，存储引擎在重启时可以通过事务日志自动进行数据恢复。具体的恢复方式会根据存储引擎的实现而有所不同

### 1.3.4 MySQL中的事务

MySQL提供了两种事务型的存储引擎：InnoDB和NDBCluster。此外，还有一些第三方存储引擎也支持事务，其中一些较知名的包括XtraDB和PBXT。后文将详细讨论它们各自的一些特点。

**自动提交（AUTOCOMMIT）**

MySQL默认采用自动提交（AUTOCOMMIT）模式。在这种模式下，如果不显式开始一个事务，则每个查询都被视为一个事务，并执行提交操作。可以通过设置AUTOCOMMIT变量来启用或禁用自动提交模式：

```mysql
sqlCopy code-- 查询当前AUTOCOMMIT的状态
SHOW VARIABLES LIKE 'AUTOCOMMIT';

-- 启用自动提交
SET AUTOCOMMIT=1;

-- 禁用自动提交
SET AUTOCOMMIT=0;
```

在AUTOCOMMIT=0时，所有的查询都处于同一个事务中，直到显式执行`COMMIT`提交或`ROLLBACK`回滚，该事务结束，同时又开始了另一个新事务。修改AUTOCOMMIT对非事务型的表（如MyISAM或内存表）没有影响。

**事务隔离级别**

MySQL可以通过执行`SET TRANSACTION ISOLATION LEVEL`命令来设置隔离级别，新的隔离级别会在下一个事务开始时生效。可以在配置文件中设置整个数据库的隔离级别，也可以仅改变当前会话的隔离级别：

```
sqlCopy code-- 设置当前会话的隔离级别为READ COMMITTED
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

MySQL能够识别所有四个ANSI隔离级别，而InnoDB引擎也支持所有的隔离级别。

**在事务中混合使用存储引擎**

MySQL服务器层不管理事务，事务是由底层的存储引擎实现的。因此，在同一个事务中混合使用多种存储引擎是不可靠的。

如果在事务中混合使用了事务型和非事务型的表（例如InnoDB和MyISAM表），在正常提交的情况下通常不会有问题。但如果需要回滚该事务，非事务型的表上的变更将无法撤销，导致数据库处于不一致的状态。因此，为每张表选择合适的存储引擎非常重要。

在非事务型的表上执行事务相关操作时，MySQL通常不会发出提醒，也不会报错。有时只有在回滚时才会发出一个警告：“某些非事务型的表上的变更不能被回滚”。

**隐式和显式锁定**

InnoDB采用两阶段锁定协议，锁只有在执行`COMMIT`或`ROLLBACK`时才会释放，所有锁在同一时刻被释放。前述描述的锁定是隐式锁定，InnoDB会根据隔离级别在需要时自动加锁。此外，InnoDB也支持通过特定的语句进行显式锁定，如`SELECT ... LOCK IN SHARE MODE`和`SELECT ... FOR UPDATE`。

MySQL还支持`LOCK TABLES`和`UNLOCK TABLES`语句，这是在服务器层实现的，与存储引擎无关。它们有自己的用途，但不能替代事务处理。如果应用需要使用事务，应该选择事务型存储引擎。

有时可以发现应用将表从MyISAM转换到InnoDB，但仍然显式地使用`LOCK TABLES`语句。这样做不仅是不必要的，还会严重影响性能，实际上InnoDB的行级锁更加高效